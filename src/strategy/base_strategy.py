"""Base strategy interface and implementation framework."""
import asyncio
from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Any, Callable
from dataclasses import dataclass, field
from datetime import datetime, timezone
from decimal import Decimal
from enum import Enum

from ..core.models.order import Order, OrderSide, OrderType, TimeInForce
from ..core.models.position import Position
from ..core.models.market_data import Bar, Quote, Trade
from ..core.logging.structured_logger import get_logger
from ..market_data.market_data_aggregator import MarketDataAggregator
from ..execution.position_tracker import PositionTracker
from ..risk.var_calculator import VaRCalculator, VaRParams
from ..risk.exposure_manager import ExposureManager


class SignalStrength(Enum):
    """Signal strength classification."""
    STRONG_BUY = "strong_buy"
    BUY = "buy"
    WEAK_BUY = "weak_buy"
    NEUTRAL = "neutral"
    WEAK_SELL = "weak_sell"
    SELL = "sell"
    STRONG_SELL = "strong_sell"


@dataclass
class Signal:
    """Trading signal generated by strategy."""
    strategy_id: str
    symbol: str
    venue: str
    side: OrderSide
    strength: SignalStrength
    confidence: float  # 0.0 to 1.0
    target_quantity: Optional[Decimal] = None
    target_price: Optional[Decimal] = None
    stop_loss: Optional[Decimal] = None
    take_profit: Optional[Decimal] = None
    metadata: Dict[str, Any] = field(default_factory=dict)
    timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    
    def to_order(self, 
                 order_type: OrderType = OrderType.LIMIT,
                 time_in_force: TimeInForce = TimeInForce.GTC) -> Order:
        """Convert signal to executable order."""
        return Order(
            symbol=self.symbol,
            venue=self.venue,
            side=self.side,
            order_type=order_type,
            quantity=self.target_quantity or Decimal('0'),
            price=self.target_price,
            stop_price=self.stop_loss,
            time_in_force=time_in_force,
            strategy_id=self.strategy_id,
            metadata={
                **self.metadata,
                'signal_strength': self.strength.value,
                'signal_confidence': self.confidence
            }
        )


@dataclass
class StrategyConfig:
    """Base strategy configuration."""
    strategy_id: str
    symbols: List[str]
    venues: List[str]
    enabled: bool = True
    
    # Position sizing
    max_position_size: Optional[float] = None
    position_size_pct: float = 0.02  # % of capital per trade
    
    # Risk parameters
    stop_loss_pct: float = 0.02
    take_profit_pct: float = 0.04
    max_daily_loss_pct: float = 0.05
    
    # Execution parameters
    use_limit_orders: bool = True
    limit_order_offset_bps: int = 5  # Basis points from mid
    max_slippage_bps: int = 50
    
    # Strategy-specific parameters
    parameters: Dict[str, Any] = field(default_factory=dict)


@dataclass
class StrategyMetrics:
    """Strategy performance metrics."""
    strategy_id: str
    
    # Trade statistics
    total_trades: int = 0
    winning_trades: int = 0
    losing_trades: int = 0
    
    # P&L metrics
    total_pnl: Decimal = Decimal('0')
    realized_pnl: Decimal = Decimal('0')
    unrealized_pnl: Decimal = Decimal('0')
    
    # Performance ratios
    win_rate: float = 0.0
    profit_factor: float = 0.0
    sharpe_ratio: float = 0.0
    max_drawdown: float = 0.0
    
    # Position metrics
    current_positions: int = 0
    average_holding_period: float = 0.0  # hours
    
    # Signal metrics
    signals_generated: int = 0
    signals_executed: int = 0
    execution_rate: float = 0.0
    
    # Timestamps
    first_trade: Optional[datetime] = None
    last_trade: Optional[datetime] = None
    last_updated: datetime = field(default_factory=lambda: datetime.now(timezone.utc))


class BaseStrategy(ABC):
    """Abstract base class for all trading strategies."""
    
    def __init__(self,
                 config: StrategyConfig,
                 market_data: MarketDataAggregator,
                 position_tracker: PositionTracker,
                 exposure_manager: ExposureManager):
        """
        Args:
            config: Strategy configuration
            market_data: Market data aggregator
            position_tracker: Position tracking system
            exposure_manager: Risk exposure manager
        """
        self.config = config
        self.market_data = market_data
        self.position_tracker = position_tracker
        self.exposure_manager = exposure_manager
        
        self.logger = get_logger(f"strategy.{config.strategy_id}")
        
        # Strategy state
        self._enabled = config.enabled
        self._running = False
        
        # Metrics tracking
        self.metrics = StrategyMetrics(strategy_id=config.strategy_id)
        
        # Signal callbacks
        self._signal_callbacks: List[Callable[[Signal], None]] = []
        
        # Internal state for derived classes
        self._state: Dict[str, Any] = {}
        
        # Lock for thread safety
        self._lock = asyncio.Lock()
    
    @property
    def strategy_id(self) -> str:
        return self.config.strategy_id
    
    @property
    def is_enabled(self) -> bool:
        return self._enabled
    
    @property
    def is_running(self) -> bool:
        return self._running
    
    def enable(self) -> None:
        """Enable strategy."""
        self._enabled = True
        self.logger.info(f"Strategy {self.strategy_id} enabled")
    
    def disable(self) -> None:
        """Disable strategy."""
        self._enabled = False
        self.logger.warning(f"Strategy {self.strategy_id} disabled")
    
    def register_signal_callback(self, callback: Callable[[Signal], None]) -> None:
        """Register callback to be called when signal is generated."""
        self._signal_callbacks.append(callback)
    
    async def start(self) -> None:
        """Start strategy execution."""
        if self._running:
            self.logger.warning(f"Strategy {self.strategy_id} already running")
            return
        
        if not self._enabled:
            self.logger.warning(f"Cannot start disabled strategy {self.strategy_id}")
            return
        
        self._running = True
        self.logger.info(f"Starting strategy {self.strategy_id}")
        
        # Initialize strategy-specific components
        await self.initialize()
        
        # Subscribe to market data
        for symbol in self.config.symbols:
            for venue in self.config.venues:
                await self.market_data.subscribe(symbol, venue, self._on_market_data)
        
        self.logger.info(f"Strategy {self.strategy_id} started successfully")
    
    async def stop(self) -> None:
        """Stop strategy execution."""
        if not self._running:
            return
        
        self.logger.info(f"Stopping strategy {self.strategy_id}")
        self._running = False
        
        # Unsubscribe from market data
        for symbol in self.config.symbols:
            for venue in self.config.venues:
                await self.market_data.unsubscribe(symbol, venue, self._on_market_data)
        
        # Cleanup strategy-specific components
        await self.cleanup()
        
        self.logger.info(f"Strategy {self.strategy_id} stopped")
    
    async def _on_market_data(self, data: Any) -> None:
        """Internal market data callback."""
        if not self._enabled or not self._running:
            return
        
        try:
            # Route to appropriate handler
            if isinstance(data, Bar):
                await self.on_bar(data)
            elif isinstance(data, Quote):
                await self.on_quote(data)
            elif isinstance(data, Trade):
                await self.on_trade(data)
            else:
                self.logger.warning(f"Unknown market data type: {type(data)}")
        
        except Exception as e:
            self.logger.error(
                f"Error processing market data in strategy {self.strategy_id}",
                error=e,
                data_type=type(data).__name__
            )
    
    async def generate_signals(self, symbol: str, venue: str) -> List[Signal]:
        """Generate trading signals for a symbol.
        
        This is the main entry point called by signal processors.
        """
        if not self._enabled:
            return []
        
        try:
            signals = await self.calculate_signals(symbol, venue)
            
            # Filter and validate signals
            validated_signals = []
            for signal in signals:
                if await self._validate_signal(signal):
                    validated_signals.append(signal)
                    self.metrics.signals_generated += 1
                    
                    # Notify callbacks
                    for callback in self._signal_callbacks:
                        try:
                            callback(signal)
                        except Exception as e:
                            self.logger.error("Signal callback error", error=e)
            
            return validated_signals
        
        except Exception as e:
            self.logger.error(
                f"Error generating signals for {symbol}@{venue}",
                error=e
            )
            return []
    
    async def _validate_signal(self, signal: Signal) -> bool:
        """Validate signal against risk constraints."""
        # Check if we can take this position
        positions = await self.position_tracker.get_all_positions()
        
        # Check position limits
        existing_position = next(
            (p for p in positions if p.symbol == signal.symbol and p.venue == signal.venue),
            None
        )
        
        if existing_position:
            # Check if signal would increase position in same direction
            if existing_position.quantity > 0 and signal.side == OrderSide.BUY:
                position_value = abs(float(existing_position.quantity * existing_position.average_entry_price))
                if position_value > (self.config.max_position_size or float('inf')):
                    self.logger.debug(f"Signal rejected: position size limit for {signal.symbol}")
                    return False
            elif existing_position.quantity < 0 and signal.side == OrderSide.SELL:
                position_value = abs(float(existing_position.quantity * existing_position.average_entry_price))
                if position_value > (self.config.max_position_size or float('inf')):
                    self.logger.debug(f"Signal rejected: position size limit for {signal.symbol}")
                    return False
        
        # Check daily loss limit
        daily_pnl = sum(float(p.realized_pnl) for p in positions)
        portfolio_value = sum(abs(float(p.quantity * (p.current_price or p.average_entry_price))) for p in positions)
        
        if portfolio_value > 0:
            daily_loss_pct = abs(daily_pnl / portfolio_value) if daily_pnl < 0 else 0
            if daily_loss_pct > self.config.max_daily_loss_pct:
                self.logger.warning(
                    f"Signal rejected: daily loss limit exceeded",
                    daily_loss_pct=daily_loss_pct,
                    limit=self.config.max_daily_loss_pct
                )
                return False
        
        return True
    
    async def update_metrics(self) -> None:
        """Update strategy performance metrics."""
        async with self._lock:
            positions = await self.position_tracker.get_strategy_positions(self.strategy_id)
            
            # Update position counts
            self.metrics.current_positions = len([p for p in positions if p.quantity != 0])
            
            # Update P&L
            self.metrics.realized_pnl = sum(p.realized_pnl for p in positions)
            self.metrics.unrealized_pnl = sum(p.unrealized_pnl for p in positions)
            self.metrics.total_pnl = self.metrics.realized_pnl + self.metrics.unrealized_pnl
            
            # Update win rate
            if self.metrics.total_trades > 0:
                self.metrics.win_rate = self.metrics.winning_trades / self.metrics.total_trades
            
            # Update execution rate
            if self.metrics.signals_generated > 0:
                self.metrics.execution_rate = self.metrics.signals_executed / self.metrics.signals_generated
            
            self.metrics.last_updated = datetime.now(timezone.utc)
    
    def get_state(self, key: str, default: Any = None) -> Any:
        """Get internal state value."""
        return self._state.get(key, default)
    
    def set_state(self, key: str, value: Any) -> None:
        """Set internal state value."""
        self._state[key] = value
    
    # Abstract methods to be implemented by concrete strategies
    
    @abstractmethod
    async def initialize(self) -> None:
        """Initialize strategy-specific components.
        
        Called when strategy starts.
        """
        pass
    
    @abstractmethod
    async def cleanup(self) -> None:
        """Cleanup strategy-specific components.
        
        Called when strategy stops.
        """
        pass
    
    @abstractmethod
    async def calculate_signals(self, symbol: str, venue: str) -> List[Signal]:
        """Calculate trading signals for a symbol.
        
        This is the core logic that must be implemented by each strategy.
        
        Args:
            symbol: Trading symbol
            venue: Trading venue
        
        Returns:
            List of trading signals
        """
        pass
    
    # Optional callback methods (can be overridden)
    
    async def on_bar(self, bar: Bar) -> None:
        """Called when new bar is received.
        
        Override to implement bar-based logic.
        """
        pass
    
    async def on_quote(self, quote: Quote) -> None:
        """Called when new quote is received.
        
        Override to implement quote-based logic.
        """
        pass
    
    async def on_trade(self, trade: Trade) -> None:
        """Called when new trade is received.
        
        Override to implement trade-based logic.
        """
        pass
    
    async def on_order_filled(self, order: Order) -> None:
        """Called when order is filled.
        
        Override to implement post-fill logic.
        """
        async with self._lock:
            self.metrics.signals_executed += 1
            self.metrics.total_trades += 1
            
            if not self.metrics.first_trade:
                self.metrics.first_trade = datetime.now(timezone.utc)
            self.metrics.last_trade = datetime.now(timezone.utc)
    
    async def on_position_update(self, position: Position) -> None:
        """Called when position is updated.
        
        Override to implement position management logic.
        """
        # Track win/loss on position close
        if position.quantity == 0 and position.realized_pnl != 0:
            async with self._lock:
                if position.realized_pnl > 0:
                    self.metrics.winning_trades += 1
                else:
                    self.metrics.losing_trades += 1
